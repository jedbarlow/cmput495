\documentclass[presentation.tex]{subfiles}
\begin{document}


\section{Definition}
\begin{frame}
  \frametitle{Definition}
  Functional Programming is programming:
  \begin{itemize}
    \item with no implicit state.
    \item where a variable, once given a value, does not ever change; it would have to alter the implicit state if it did.
    \item where there are no loops, only recursion.
    \item where you tell your computer what to do rather than how to do it.
    \item where a program is made of trees of functions.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Definition}
  Functional Programming is programming pure functions.
  \vspace{\baselineskip}
  Pure functions are functions that:
  \begin{itemize}
    \item the only accessible element of a function is its output.
    \item the only things that affect the output is the inputs.
    \item the inputs are fully determined before the output is generated.
  \end{itemize}
  \vspace{\baselineskip}
  A pure function will always yield the same output given the same input.
\end{frame}


\section{History}
\begin{frame}
  \frametitle{History}
  It is normally accepted that the basis for functional language is lambda calculus; created by Alonzo Church. Most functional languages are just extensions on lambda calculus.
  \vspace{\baselineskip}
  The first functional language you could code in was Lisp. Lisp was first conceptualized in the late 50s by John McCarthy as a means to process lists algebraically to help his research into artificial intelligence.
  \vspace{\baselineskip}
  Lisp is known as one of the most influential languages ever written. It had enough influence to create commercially available computers optimized for it known as Lisp Machines. Interestingly enough the first .com domain was registered to a Lisp Machine manufacturer names Symbolics.
\end{frame}

\begin{frame}
  \frametitle{History}
  As functional languages developed none could quite manage to be purely functional as problems developed like how to handle I/O. Even lisp had goto statements.
  \vspace{\baselineskip}
  Haskell is a fairly new functional language that attempts to be purely functional.
\end{frame}


\section{Motivation}
\begin{frame}
  \frametitle{Motivation}
  A functional program is often much shorter than a imperative program. This also helps to make them often much easier to understand and write without errors.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Motivation}
  Quicksort written in haskell:
  \begin{lstlisting}[language=Haskell]
    quicksort :: Ord a => [a] -> [a]
    quicksort [] = []
    quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater)
        where
          lesser = filter (< p) xs
          greater = filter (>= p) xs
  \end{lstlisting}
  \vspace{\baselineskip}
  An even shorter quicksort, notice the set builder notation:
  \begin{lstlisting}[language=Haskell]
    qsort (p:xs) = qsort [x | x<-xs, x<p] ++ [p] ++ qsort [x | x<-xs, x>=p]
  \end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Motivation}
  Possibly the greatest advantage of functional programming is that since you are writing pure functions, there are no side effects.
  \vspace{\baselineskip}
  In other words it is easy to see what any output will be given a input.
\end{frame}

\begin{frame}
  \frametitle{Motivation}
  Another strong advantage of functional programming is since variables are immutable we never have to guess what they will be at a certain point in a program.
  \vspace{\baselineskip}
  Some of the largest issues in parallel computing is that the data being manipulated by one process can be affected by another process. The immutability of data and the lack of side effects in functional languages avoid these problems and make them ideal candidates for parallel programming.
\end{frame}

\end{document}
