\documentclass[presentation.tex]{subfiles}

\begin{document}


\section{Definition}
\begin{frame}
  \frametitle{Definition}
  Functional Programming can be best summarized as creating programs that consist solely of functions.

  \vspace{\baselineskip}
  A program written in a functional language can be though of as a tree with a single main function which subsequently calls other functions, which call other functions, etcetera.

  \vspace{\baselineskip}
  Functions consist of input, a manipulation of that input, and an output. In functional programming the same input should always lead to the same output. This means there is predictability!

  \vspace{\baselineskip}
  The most shocking thing about functional languages is that a variable, once given a value, will never change. You can think of variables in a functional language like variables in mathematics. % Reinforces the paradigm of same input yields same output.

  % Functions are first class citizens.
\end{frame}


\begin{frame}
  \frametitle{History}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Motivation}
  A functional program is often much shorter than a imperative program. This also helps to make them often much easier to understand and write without errors.

  \vspace{\baselineskip}
  Quicksort written in haskell:

  \begin{lstlisting}[language=Haskell]
    quicksort :: Ord a => [a] -> [a]
    quicksort [] = []
    quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater)
        where
          lesser = filter (< p) xs
          greater = filter (>= p) xs
  \end{lstlisting}

  \vspace{\baselineskip}
  This quicksort will sort anything where sort could be defined on. There is no need to specify a type or a size.
\end{frame}

\begin{frame}[fragile]
  \vspace{\baselineskip}
  An even shorter quicksort, notice the set builder notation:

  \begin{lstlisting}[language=Haskell]
    qsort (p:xs) = qsort [x | x<-xs, x<p] ++ [p] ++ qsort [x | x<-xs, x>=p]
  \end{lstlisting}
\end{frame}


\end{document}
